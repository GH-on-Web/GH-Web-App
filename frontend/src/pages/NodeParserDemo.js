import React, { useState, useEffect } from 'react';
import { useParams } from 'react-router-dom';
import { useTheme } from '@mui/material';
import { IconButton, Box, Button } from '@mui/material';
import { ChevronLeft, ChevronRight, Save, FolderOpen, Delete, PlayArrow, Comment } from '@mui/icons-material';
import { RoomProvider, useSelf, useUpdateMyPresence } from '@liveblocks/react';
import { NodeParser } from '../components/NodeParser';
import { useGraphCollaboration } from '../hooks/useCollaboration';
import CollaborationStatus from '../components/Collaboration/CollaborationStatus';
import { LiveCursorsContainer } from '../components/Collaboration/LiveCursors';
import { CommentsPanel } from '../components/Collaboration/CommentsPanel';
import ThreeViewer from '../components/Viewer3D/ThreeViewer';
import ErrorBoundary from '../components/ErrorBoundary';
import { POSITION_SCALE_FACTOR } from '../utils/nodeParser';
import exampleData from '../data/exampleGraph.json';
import exampleDataInteractive from '../data/exampleGraphInteractive.json';
import testScript1 from '../data/Test-Script-1.json';
import './NodeParserDemo.css';

/**
 * Inner component that uses Liveblocks room for real-time collaboration
 */
const NodeParserDemoContent = ({ roomId }) => {
  const theme = useTheme();
  const self = useSelf();
  const updateMyPresence = useUpdateMyPresence();
  
  // Collaboration mode toggle
  const [isCollabMode, setIsCollabMode] = useState(false);
  
  // 3D viewer collapse state (following AppLayout pattern)
  const [isViewerCollapsed, setIsViewerCollapsed] = useState(true);
  
  // Comments panel state
  const [commentsOpen, setCommentsOpen] = useState(false);
  
  // Sample geometry for demonstration
  const [sampleGeometry, setSampleGeometry] = useState(null);
  
  // Use Liveblocks for collaborative state
  const {
    graphData: currentData,
    updateGraphData,
    updateGraphNodes,
    updateGraphLinks,
    isConnected,
    others
  } = useGraphCollaboration();
  
  // Set user info in presence
  useEffect(() => {
    if (self && self.connectionId) {
      const connectionIdStr = String(self.connectionId);
      const userName = `User ${connectionIdStr.slice(0, 4)}`;
      const currentPresence = self.presence || {};
      updateMyPresence({
        ...currentPresence,
        name: userName,
        color: null, // Will be auto-generated by useLiveCursors
      });
    }
  }, [self, updateMyPresence]);
  
  const [jsonInput, setJsonInput] = useState(JSON.stringify(currentData, null, 2));
  const [parseError, setParseError] = useState(null);
  const [componentsDatabase, setComponentsDatabase] = useState([]);
  const [isLoadingDatabase, setIsLoadingDatabase] = useState(true);

  // Sync JSON input when currentData changes from Liveblocks
  useEffect(() => {
    setJsonInput(JSON.stringify(currentData, null, 2));
  }, [currentData]);

  // Load the components database
  useEffect(() => {
    const loadDatabase = async () => {
      try {
        const response = await fetch('/gh_components_native.json');
        if (response.ok) {
          const data = await response.json();
          if (data && data.Components) {
            setComponentsDatabase(data.Components);
            console.log(`Loaded ${data.Components.length} components from database`);
          } else {
            console.error('No components found in database');
          }
        } else {
          console.error('Failed to fetch database:', response.statusText);
        }
        setIsLoadingDatabase(false);
      } catch (error) {
        console.error('Failed to load components database:', error);
        setIsLoadingDatabase(false);
      }
    };
    
    loadDatabase();
  }, []);

  const handleLoadFile = () => {
    // Warn if others are connected and collab mode is active
    if (isCollabMode && others.length > 0) {
      const confirmed = window.confirm(
        `${others.length} other user(s) are viewing this workspace. Loading a file will replace their view. Continue?`
      );
      if (!confirmed) return;
    }
    
    // Create a file input element
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    
    input.onchange = (e) => {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (event) => {
          try {
            const fileContent = event.target.result;
            const parsed = JSON.parse(fileContent);
            updateGraphData(parsed);
            setParseError(null);
          } catch (err) {
            setParseError('Failed to load file: ' + err.message);
          }
        };
        reader.readAsText(file);
      }
    };
    
    input.click();
  };

  const handleLoadExample = () => {
    if (isCollabMode && others.length > 0) {
      const confirmed = window.confirm(
        `${others.length} other user(s) are viewing this workspace. Loading an example will replace their view. Continue?`
      );
      if (!confirmed) return;
    }
    updateGraphData(testScript1);
    setParseError(null);
  };

  const handleLoadVanillaExample = () => {
    if (isCollabMode && others.length > 0) {
      const confirmed = window.confirm(
        `${others.length} other user(s) are viewing this workspace. Loading an example will replace their view. Continue?`
      );
      if (!confirmed) return;
    }
    updateGraphData(exampleData);
    setParseError(null);
  };
  
  const handleLoadInteractiveExample = () => {
    if (isCollabMode && others.length > 0) {
      const confirmed = window.confirm(
        `${others.length} other user(s) are viewing this workspace. Loading an example will replace their view. Continue?`
      );
      if (!confirmed) return;
    }
    updateGraphData(exampleDataInteractive);
    setParseError(null);
  };

  const handleParseJson = () => {
    try {
      const parsed = JSON.parse(jsonInput);
      updateGraphData(parsed);
      setParseError(null);
    } catch (err) {
      setParseError('Invalid JSON: ' + err.message);
    }
  };

  const handleClear = () => {
    const emptyData = { nodes: [], links: [] };
    updateGraphData(emptyData);
    setParseError(null);
  };

  const handleConnectionsChange = (newConnections) => {
    // Detect format and update accordingly
    const isSimplifiedFormat = currentData.nodes && currentData.links;
    
    // Convert connections to the appropriate format
    let formattedConnections = newConnections;
    
    if (isSimplifiedFormat) {
      // Convert from React Flow edge format {sourceNodeId: "node-xyz", sourceHandle: "output-0", ...}
      // to simplified format {fromNode: "xyz", fromParam: "0", toNode: "abc", toParam: "A"}
      formattedConnections = newConnections.map(conn => {
        // Remove "node-" prefix from IDs
        const fromNode = conn.sourceNodeId?.replace(/^node-/, '');
        const toNode = conn.targetNodeId?.replace(/^node-/, '');
        
        // Extract param from handle ID (e.g., "output-0" -> "0", "input-A" -> "A")
        const fromParam = conn.sourceHandle?.replace(/^output-/, '') || "0";
        const toParam = conn.targetHandle?.replace(/^input-/, '') || "0";
        
        return {
          fromNode,
          fromParam,
          toNode,
          toParam
        };
      });
    }
    
    // Update links in Liveblocks
    updateGraphLinks(formattedConnections);
  };

  const handleNodesChange = (newNodes, newComponentInstance, deletedNodeIds, isPositionUpdate) => {
    // Detect format
    const isSimplifiedFormat = currentData.nodes && currentData.links;
    
    // If nodes are being deleted
    if (deletedNodeIds && deletedNodeIds.length > 0) {
      if (isSimplifiedFormat) {
        const updatedNodes = currentData.nodes?.filter(
          node => !deletedNodeIds.includes(`node-${node.id}`)
        ) || [];
        
        // Also filter out links connected to deleted nodes
        const updatedLinks = (currentData.links || []).filter(link => {
          const sourceNodeId = `node-${link.fromNode}`;
          const targetNodeId = `node-${link.toNode}`;
          return !deletedNodeIds.includes(sourceNodeId) && !deletedNodeIds.includes(targetNodeId);
        });
        
        // Update both nodes and links
        updateGraphData({
          nodes: updatedNodes,
          links: updatedLinks
        });
      } else {
        const updatedInstances = currentData.componentInstances?.filter(
          inst => !deletedNodeIds.includes(`node-${inst.instanceId}`)
        ) || [];
        
        // Filter out connections to deleted nodes
        const updatedConnections = (currentData.connections || []).filter(conn => {
          return !deletedNodeIds.includes(conn.sourceNodeId) && !deletedNodeIds.includes(conn.targetNodeId);
        });
        
        updateGraphData({
          componentInstances: updatedInstances,
          connections: updatedConnections
        });
      }
      return;
    }
    
    // If a new component instance is being added
    if (newComponentInstance) {
      if (isSimplifiedFormat) {
        // Convert newComponentInstance to simplified format
        const reactFlowNode = newNodes?.find(n => n.id === `node-${newComponentInstance.instanceId}`);
        
        if (reactFlowNode) {
          // Get GUID from component data or from the node data
          const guid = newComponentInstance.component?.guid || 
                       newComponentInstance.component?.Guid || 
                       reactFlowNode.data.guid;
          
          const newSimplifiedNode = {
            id: newComponentInstance.instanceId,
            guid: guid,
            nickname: reactFlowNode.data.nickname || reactFlowNode.data.name,
            x: newComponentInstance.position.x / POSITION_SCALE_FACTOR,
            y: newComponentInstance.position.y / POSITION_SCALE_FACTOR,
            properties: {}
          };
          
          // Add properties for interactive nodes
          if (reactFlowNode.type === 'numberSlider') {
            newSimplifiedNode.properties = {
              Min: reactFlowNode.data.min || 0,
              Max: reactFlowNode.data.max || 100,
              Step: reactFlowNode.data.step || 1,
              Value: reactFlowNode.data.value || 0
            };
          } else if (reactFlowNode.type === 'panel') {
            newSimplifiedNode.properties = {
              Text: reactFlowNode.data.text || '',
              IsInput: reactFlowNode.data.isInput || false
            };
          } else if (reactFlowNode.type === 'booleanToggle') {
            newSimplifiedNode.properties = {
              Value: reactFlowNode.data.value || false
            };
          } else if (reactFlowNode.type === 'numberInput') {
            newSimplifiedNode.properties = {
              Value: reactFlowNode.data.value || 0
            };
          }
          
          const updatedNodes = [...(currentData.nodes || []), newSimplifiedNode];
          updateGraphNodes(updatedNodes);
        }
      } else {
        const updatedInstances = [...(currentData.componentInstances || []), newComponentInstance];
        updateGraphData({
          componentInstances: updatedInstances,
          connections: currentData.links || currentData.connections || []
        });
      }
      return;
    }
    
    // If this is a position update (node drag), update positions without triggering re-parse
    if (isPositionUpdate && newNodes) {
      if (isSimplifiedFormat) {
        const updatedNodes = currentData.nodes?.map(node => {
          const reactFlowNode = newNodes.find(n => n.id === `node-${node.id}`);
          if (reactFlowNode && reactFlowNode.position) {
            return {
              ...node,
              x: reactFlowNode.position.x / POSITION_SCALE_FACTOR,
              y: reactFlowNode.position.y / POSITION_SCALE_FACTOR
            };
          }
          return node;
        }) || [];
        
        updateGraphNodes(updatedNodes);
      } else {
        const updatedInstances = currentData.componentInstances?.map(inst => {
          const node = newNodes.find(n => n.id === `node-${inst.instanceId}`);
          if (node && node.position) {
            return {
              ...inst,
              position: node.position
            };
          }
          return inst;
        }) || [];
        
        updateGraphData({
          componentInstances: updatedInstances,
          connections: currentData.links || currentData.connections || []
        });
      }
      return;
    }
    
    // For other node movements/updates, don't trigger re-parse
    // This prevents the graph from re-parsing and losing edges
  };

  const handleExportConnections = () => {
    const connectionsJson = JSON.stringify(currentData.links || currentData.connections || [], null, 2);
    // Create a downloadable file
    const blob = new Blob([connectionsJson], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'connections.json';
    a.click();
    URL.revokeObjectURL(url);
  };

  const handleExportGraph = () => {
    const graphJson = JSON.stringify(currentData, null, 2);
    // Create a downloadable file
    const blob = new Blob([graphJson], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'grasshopper-graph.json';
    a.click();
    URL.revokeObjectURL(url);
  };

  const handleRun = () => {
    // Export current canvas graph (will be replaced with backend call later)
    //handleExportGraph();
    
    // Generate sample geometry for 3D viewer
    generateSampleGeometry();
  };

  // Generate sample geometry for demonstration
  const generateSampleGeometry = () => {
    // Create a simple box geometry using Three.js format
    const geometry = {
      type: 'box',
      width: 2,
      height: 2,
      depth: 2,
      position: [0, 0, 0],
      color: [0.2, 0.6, 1.0, 1.0] // Blue color
    };
    
    setSampleGeometry(geometry);
  };

  return (
    <div className={`node-parser-demo ${!isViewerCollapsed ? 'with-3d-viewer' : ''}`} data-theme={theme.palette.mode}>
      {/* Collaboration toggle button */}
      <div style={{ position: 'absolute', top: '20px', left: '20px', zIndex: 102 }}>
        <button 
          onClick={() => setIsCollabMode(!isCollabMode)}
          className="btn"
          style={{
            backgroundColor: isCollabMode ? '#4caf50' : theme.palette.mode === 'dark' ? '#424242' : '#e0e0e0',
            color: isCollabMode ? 'white' : theme.palette.mode === 'dark' ? 'white' : 'black',
            padding: '8px 16px',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer',
            fontWeight: 'bold',
            boxShadow: '0 2px 4px rgba(0,0,0,0.2)'
          }}
          title={isCollabMode ? 'Stop collaboration mode' : 'Start collaboration mode'}
        >
          {isCollabMode ? 'üõë Stop Collab' : 'üöÄ Start Collab'}
        </button>
      </div>

      {/* Collaboration status indicator - only show in collab mode */}
      {isCollabMode && (
        <div style={{ position: 'absolute', top: '70px', left: '20px', zIndex: 101 }}>
          <CollaborationStatus workspaceId={roomId} />
        </div>
      )}
      
      <div className="demo-canvas">
        {isLoadingDatabase ? (
          <div className="loading-message">
            Loading components database...
          </div>
        ) : componentsDatabase.length === 0 ? (
          <div className="loading-message" style={{background: '#fff3cd', color: '#856404'}}>
            ‚ö†Ô∏è Components database not loaded. Some features may not work correctly.
          </div>
        ) : null}
        
        <LiveCursorsContainer
          enabled={isCollabMode}
          className={`canvas-container ${!isViewerCollapsed ? 'with-3d-viewer' : ''}`}
          style={{ display: 'flex', height: '100%', width: '100%' }}
        >
          <div className="graph-canvas">
            <NodeParser
              graphData={currentData}
              onConnectionsChange={handleConnectionsChange}
              onNodesChange={handleNodesChange}
              componentsDatabase={componentsDatabase}
            />
          </div>
          
        {/* 3D Viewer Panel */}
        {!isViewerCollapsed && (
          <>
            <div className="viewer-panel">
                <div style={{ 
                  padding: '8px', 
                  background: theme.palette.mode === 'dark' ? '#333' : '#f0f0f0',
                  borderBottom: '1px solid #ddd',
                  fontSize: '12px',
                  color: theme.palette.mode === 'dark' ? '#ccc' : '#666'
                }}>
                  3D Preview {sampleGeometry ? '(Sample Cube)' : '(No geometry)'}
                </div>
                <ErrorBoundary>
                  <ThreeViewer geometry={sampleGeometry} />
                </ErrorBoundary>
              </div>
              {/* Close button for expanded viewer - now outside the panel */}
              <Box
                sx={{
                  position: 'absolute',
                  left: 'calc(100% - 400px - 30px)',
                  top: '50%',
                  transform: 'translateY(-50%)',
                  zIndex: 103,
                  pointerEvents: 'auto',
                }}
              >
                <IconButton
                  size="small"
                  onClick={() => setIsViewerCollapsed(true)}
                  sx={{
                    bgcolor: 'primary.main',
                    color: 'primary.contrastText',
                    border: 1,
                    borderColor: 'divider',
                    boxShadow: 2,
                    '&:hover': {
                      bgcolor: 'primary.dark',
                    },
                    width: '40px',
                    height: '40px',
                  }}
                  title="Hide 3D viewer"
                >
                  <ChevronRight fontSize="medium" />
                </IconButton>
            </Box>
          </>
        )}

        {/* 3D Viewer Toggle Button - only show when collapsed */}
        {isViewerCollapsed && (
          <Box
            sx={{
              position: 'absolute',
              right: '10px',
              top: '50%',
              transform: 'translateY(-50%)',
              zIndex: 103,
            }}
          >
            <IconButton
              size="small"
              onClick={() => setIsViewerCollapsed(false)}
              sx={{
                bgcolor: 'primary.main',
                color: 'primary.contrastText',
                border: 1,
                borderColor: 'divider',
                boxShadow: 2,
                '&:hover': {
                  bgcolor: 'primary.dark',
                },
                width: '40px',
                height: '40px',
              }}
              title="Show 3D viewer"
            >
              <ChevronLeft fontSize="medium" />
            </IconButton>
          </Box>
        )}
        </LiveCursorsContainer>

        {/* Floating action buttons */}
        <Box
        sx={{
          position: 'absolute',
          top: '20px',
          right: isViewerCollapsed ? '20px' : '440px',
          zIndex: 100,
          display: 'flex',
          gap: 1,
        }}
      >
        <Button
          variant="contained"
          onClick={handleExportGraph}
          title="Save graph as JSON file"
          startIcon={<Save />}
          sx={{
            bgcolor: theme.palette.mode === 'dark' ? '#424242' : '#e0e0e0',
            color: theme.palette.mode === 'dark' ? 'white' : 'black',
            '&:hover': {
              bgcolor: theme.palette.mode === 'dark' ? '#525252' : '#d0d0d0',
            },
            textTransform: 'none',
            fontWeight: 'bold',
            boxShadow: '0 2px 4px rgba(0,0,0,0.2)',
          }}
        >
          Save
        </Button>
        <Button
          variant="contained"
          onClick={handleLoadFile}
          title="Load JSON file"
          startIcon={<FolderOpen />}
          sx={{
            bgcolor: theme.palette.mode === 'dark' ? '#424242' : '#e0e0e0',
            color: theme.palette.mode === 'dark' ? 'white' : 'black',
            '&:hover': {
              bgcolor: theme.palette.mode === 'dark' ? '#525252' : '#d0d0d0',
            },
            textTransform: 'none',
            fontWeight: 'bold',
            boxShadow: '0 2px 4px rgba(0,0,0,0.2)',
          }}
        >
          Load
        </Button>
        <Button
          variant="contained"
          onClick={handleClear}
          title="Clear canvas"
          startIcon={<Delete />}
          sx={{
            bgcolor: theme.palette.mode === 'dark' ? '#424242' : '#e0e0e0',
            color: theme.palette.mode === 'dark' ? 'white' : 'black',
            '&:hover': {
              bgcolor: theme.palette.mode === 'dark' ? '#525252' : '#d0d0d0',
            },
            textTransform: 'none',
            fontWeight: 'bold',
            boxShadow: '0 2px 4px rgba(0,0,0,0.2)',
          }}
        >
          Clear
        </Button>
        <Button
          variant="contained"
          onClick={handleRun}
          title="Export and run (coming soon)"
          startIcon={<PlayArrow />}
          sx={{
            bgcolor: theme.palette.mode === 'dark' ? '#424242' : '#e0e0e0',
            color: theme.palette.mode === 'dark' ? 'white' : 'black',
            '&:hover': {
              bgcolor: theme.palette.mode === 'dark' ? '#525252' : '#d0d0d0',
            },
            textTransform: 'none',
            fontWeight: 'bold',
            boxShadow: '0 2px 4px rgba(0,0,0,0.2)',
          }}
        >
          Run
        </Button>
        </Box>

        {/* Comments button */}
        {isCollabMode && (
          <Box
          sx={{
            position: 'absolute',
            right: '20px',
            top: '70px',
            zIndex: 101,
          }}
        >
          <IconButton
            onClick={() => setCommentsOpen(true)}
            sx={{
              bgcolor: 'primary.main',
              color: 'primary.contrastText',
              boxShadow: 2,
              '&:hover': {
                bgcolor: 'primary.dark',
              },
            }}
            title="Open comments"
          >
            <Comment />
          </IconButton>
          </Box>
        )}

        {/* Comments Panel */}
        <CommentsPanel
          open={commentsOpen}
          onClose={() => setCommentsOpen(false)}
        />
      </div>
    </div>
  );
};

/**
 * Wrapper component that provides RoomProvider for collaboration
 * Note: LiveblocksProvider is in App.js, so RoomProvider can be used here
 */
const NodeParserDemo = () => {
  const { workspaceId } = useParams();
  const roomId = workspaceId || 'nodeparser-default';

  return (
    <RoomProvider
      id={roomId}
      initialPresence={{
        cursor: null,
        name: null,
        color: null,
      }}
      initialStorage={{
        graphData: testScript1, // Initial data for new rooms
        comments: [],
        threads: {},
      }}
    >
      <NodeParserDemoContent roomId={roomId} />
    </RoomProvider>
  );
};

export default NodeParserDemo;
